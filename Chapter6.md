# 序列：字符串、列表和元组
列表类 型和元组类型就是其他一些 Python 对象所组成的序列。

序列类型操作符：

|序列操作符|作用
|:--|:--
|seq[ind]| 获得下标为 ind 的元素
|seq[ind1:ind2]| 获得下标从ind1到ind2间的元素集合
|seq * expr| 序列重复 expr 次
|seq1 + seq2| 连接序列 seq1 和 seq2
|obj in seq| 判断 obj 元素是否包含在 seq 中
|obj not in seq| 判断 obj 元素是否不包含在 seq 中


连接操作符（+）:

    该表达式的结果是一个包含 sequence1 和 sequence2 的内容的新序列.注意,这种方式看 起来似乎实现了把两个序列内容合并的概念,但是这个操作不是最快或者说最有效的。对字符 串来说,这个操作不如把所有的子字符串放到一个列表或可迭代对象中,然后调用一个 join 方法来把所有的内容连接在一起节约内存;类似地,对列表来说,我们推荐读者用列表类型的 extend()方法来把两个或者多个列表对象合并.当你需要简单地把两个对象的内容合并,或者说 不能依赖于可变对象的那些没有返回值(实际上它返回一个 None)的内建方法来完成的时候时, 连接操作符还是很方便的一个选择

切片操作符 ([], [:], [::])：

    简单地讲,所谓序列类型就是包含一些顺序排列的对象的一个结构
    访问某一个元素的语法如下：
    secquence[index]
        sequence 是序列的名字,index 是想要访问的元素对应的偏移量.偏移量可以是正值,范围 从 0 到偏移最大值(比序列长度少一),用 len()函数(下一节会讲),可以得到序列长度,实际 的范围是 0 \<= inde \<= len(sequece)-1 .另外,也可以使用负索引,范围是 -1 到序列的负 长度,-len(sequence), -len(sequence) \<= index \<= -1.正负索引的区别在于正索引以序列 的开始为起点,负索引以序列的结束为起点.试图访问一个越界的索引会引发一个如下的异常
    
    sequence[starting_index:ending_index]：
        通过这种方式我们可以得到从起始索引到结束索引(不包括结束索引对应的元素)之间的 一"片"元素.起始索引和结束索引都是可选的,如果没有提供或者用 None 作为索引值,切片操作 会从序列的最开始处开始,或者直到序列的最末尾结束.

    用步长索引来进行扩展的切片操作
        序列的最后一个切片操作是扩展切片操作,它多出来的第三个索引值被用做步长参数


#### 类型转换
内建函数 list(), str() 和 tuple() 被用做在各种序列类型之间转换。可以理解成其他类型语言里面的类型转换，但是并没有进行任何的转换。这些转换实际上是工厂函数，将对象作为参数，并将其内容（浅）拷贝到新生成的对象中。

序列类型转换工厂

|函数          |含义
|:---|:---
|list(iter)   |把可迭代对象转换为列表
|str(obj)     |把 obj 对象转换成字符串(对象的字符串表示法)
|unicode(obj) |把对象转换成 Unicode 字符串(使用默认编码)
|basestring() |抽象工厂函数,其作用仅仅是为 str 和 unicode 函数提供父类,所以不能被实例化,也不能被调用
|tuple(iter)  |把一个可迭代对象转换成一个元组对象

所谓浅拷贝就是只拷贝了对对象的索引,而不是重新建立了一个对象!如果你想完全的拷 贝一个对象(包括递归,如果你的对象是一个包含在容器中的容器),你需要用到深拷贝


#### 字符串模板
形式：

    from string import Template
    >>> from string import Template
    >>> s = Template('There are ${howmany} ${lang} Quotation Symbols')
    >>>
    >>> print s.substitute(lang='Python', howmany=3)
    There are 3 Python Quotation Symbols

Template 对象 有两个方法,substitute()和 safe_substitute().前者更为严谨,在 key 缺少的情况下它会报一 个 KeyError 的异常出来,而后者在缺少 key 时,直接原封不动的把字符串显示出来.

#### Unicode 字符串
pickle 模块只支持 ASCII 字符串，而无法处理 Unicode 字符串，所以最好避免基于文本的 pickle 操作，pickle 的二进制格式支持不错，这点在你向数据库存东西时变得尤为突出，因此将它们作为 BLOB 字段存储而不是作为 TEXT 或者 VARCHAR 字段存储要好很多。


### 列表操作
####重复操作符（\*）:
重复操作符可能更多的应用在字符串类型中,不过,列表和元组跟字符串同属序列类型,所 以需要的时候也可以使用这一操作.


### 元组操作
虽然元组对象本身是不可变的,但这并不意味着元组包含的可变对象也不可变了，比如：

    >>> t = (['xyz', 123], 23, -103.4)
    >>> t[0][1] = ['abc', 'def']
    >>> t
    (['xyz', ['abc', 'def']], 23, -103.4)

### 单元素元组
直接使用如下方式无法建立一个单元素元组：

    >>> ('xyz')
    'xyz'
    >>> type(('xyz')) # a string, not a tuple
    <type 'str'>

这里是因为圆括号被重载了，它也被用做分组操作符。由圆括号包裹的一个单一元素首先被作为分组操作，而不是作为元组的分界符。一个变通的做法是在第一个元素后面添加一个逗号（,）来表明这是一个元组而不是在做分组操作。

    >>> ('xyz',)
    ('xyz',)

### 字典中的关键字
不可变对象的值是不可改变的。这就意味着它们通过 hash 算法得到的值总是一个值。这是 作为字典键值的一个必备条件

键值必须是可哈希的对象，元组变量符合这个标准，而列表对象就不行。

#### 关于为什么需要 tuple 和 list 两个相似的结构
tuple 华为 list 是应用于两个不同的目的，list 是可以进行动态修改的，因此更多的用于需要进行动态改变参数时，而 tuple 是不可变的，它可以用于需要保证参数安全的情况下。但是这两者之间可以简单地通过转换函数进行转换。

#### 与序列类型相关的模块

|模块|内容
|:--|:--
|数组|一种受限制的可变序列类型，要求所有的元素必须都是相同的类型
|copy|提供浅拷贝和深拷贝的能力
|operator|包含函数调用形式的序列操作符，比如 operator.contact(m, n) 就相当于连接操作 (m + n)
|re|Perl 风格的正则表达式查找（和匹配）
|cStringIO|把长字符串作为文件来操作，比如 read()，seek() 函数等
|Textwarp|用作包裹/填充文本的函数，也有一个类
|types|包含 pytohn 支持的所有类型
|collections|高性能容器数据类型

### 拷贝 python 对象：浅拷贝和深拷贝
序列类型对象的浅拷贝是默认类型拷贝，并可以以下几种方式实施：（1）完全切片操作[:]，（2）利用工厂函数，比如 list(), dict() 等，（3）使用 copy 模块的 copy 函数

    >>> person = ['name', ['savings', 100.00]]
    >>> hubby = person[:] # slice copy
    >>> wifey = list(person) # fac func copy
    >>> [id(x) for x in person, hubby, wifey]
    [11826320, 12223552, 11850936]
    >>> hubby[0] = 'joe'
    >>> wifey[0] = 'jane'
    >>> hubby, wifey
    (['joe', ['savings', 100.0]], ['jane', ['savings', 100.0]])
     >>> hubby[1][1] = 50.00
     >>> hubby, wifey
     (['joe', ['savings', 50.0]], ['jane', ['savings', 50.0]])

如上代码，为他们创建了初始有$100 的个人存款帐户。用户名改为定制的名字。但是,当丈夫取走$50 后,他的行为影响到了他妻子的账户,虽然我们进行了分开的拷贝操作。而我们希望他们之间不互相影响。

原因是我们仅仅做了一个浅拷贝。对一个对象进行浅拷贝其实是新创建了一个类型跟原对象一样,其内容是原来对象元素的引用,换句话说,这个拷贝的对象本身是新的,但是它的内容不是

但是，为什么当妻子的名字被赋值的时候，丈夫的名字没有受到影响？

这是因为 在这两个列表的两个对象中,第一个对象是不可变的(是个字符串类型),而第二个是可变的(一 个列表).正因为如此,当进行浅拷贝时,字符串被显式的拷贝,并新创建了一个字符串对象,而列 表元素只是把它的引用复制了一下,并不是它的成员.所以改变名字没有任何问题,但是更改他 们银行账号的任何信息都会引发问题

现在,让我们分别看一下每个列表的元素的对象 ID 值,注 意,银行账号对象是同一个对象,这也是为什么对一个对象进行修改会影响到另一个的原因.注 意在我们改变他们的名字后,新的名字字符串是如何替换原有'名字'字符串的.

    BEFORE:
    >>> [id(x) for x in hubby]
    [9919616, 11826320]
    >>> [id(x) for x in wifey]
    [9919616, 11826320]
    AFTER:
    >>> [id(x) for x in hubby]
    [12092832, 11826320]
    >>> [id(x) for x in wifey]
    [12191712, 11826320]

那么，如果需要使得这对夫妻的账户是分离的，也就是要得到一个完全拷贝或者深拷贝 -- 创建一个新的容器对象，包含原有对象元素（引用）全新拷贝的引用 -- 需要 copy.deepcopy() 函数。比如，修改后的深拷贝例子如下：

    >>> person = ['name', ['savings', 100.00]]
    >>> hubby = person
    >>> import copy
    >>> wifey = copy.deepcopy(person)
    >>> [id(x) for x in person, hubby, wifey]
    [12242056, 12242056, 12224232]
    >>> hubby[0] = 'joe'
    >>> wifey[0] = 'jane'
    >>> hubby, wifey
    (['joe', ['savings', 100.0]], ['jane', ['savings', 100.0]])
    >>> hubby[1][1] = 50.00
    >>> hubby, wifey
    (['joe', ['savings', 50.0]], ['jane', ['savings', 100.0]])

此时，所有四个对象都是不同的：

    >>> [id(x) for x in hubby]
    [12191712, 11826280]
    >>> [id(x) for x in wifey]
    [12114080, 12224792]


以下有几点关于拷贝操作的警告：

1. 非容器类型（比如数字，字符串和其他"原子"类型的对象，像代码，类型和 xrange 对象等）没有拷贝一说，浅拷贝是用完全切片操作来完成的
2. 如果元组变量只包含原子类型对象，对它的深拷贝将不会进行

如果我们把账户信息改成元组类 型,那么即便按我们的要求使用深拷贝操作也只能得到一个浅拷贝:

    >>> person = ['name', ('savings', 100.00)]
    >>> newPerson = copy.deepcopy(person)
    >>> [id(x) for x in person, newPerson]
    [12225352, 12226112]
    >>> [id(x) for x in person]
    [9919616, 11800088]
    >>> [id(x) for x in newPerson]
    [9919616, 11800088]














