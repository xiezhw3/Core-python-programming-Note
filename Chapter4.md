# python 对象

### python 对象
所有的 pytohn 对象都拥有三个特性：身份，类型和值

- 身份：每一个对象都有一个唯一的身份标识自己，任何对象的身份都可以使用内建函数 id() 来得到。这个值可以被认为是对象的内存地址。
- 类型：对象的类型决定了该对象可以保存什么类型的值，可以进行什么样的操作，以及遵循什么样的规则。你可以用内建函数 type() 查看 python 对象的类型。因为在 python 中类型也是对象
- 值：对象表示的数据项

### 对象类型
#### 类型对象和 type 类型对象

    >>> type(42)
    <type 'int'>

在上面 type 的返回值中，我们应该看到，它并不是一个简简单单的告诉你 42 是个整数这样的字符串。\<type 'int'\> 实际上是一个类型对象，另外，类in修改对象的类型，如下：

    >>> type(type(42))
    <type 'type'>

可以看到，所有类型对象的类型都是 type，它也是所有 python 类型的根和所有 python 标准类的默认元类。

下列对象的布尔值是 False：

- None
- False (布尔类型)
- 所有的值为零的数
- 0 (整型)
- (浮点型)
- 0L (长整型)
- 0.0+0.0j (复数)
- "" (空字符串)
- [] (空列表)
- () (空元组)
- {} (空字典)


### 内部类型

- 代码对象：代码对象是编译过的 pytohn 源码片段，它是可执行对象。通过调用内建函数 compile() 可以得到代码对象。代码对象本身不包含任何执行环境信息，它是用户自定义函数的核心，在被执行时动态获得上下文。事实上代码对象是函数的一个属性
- 帧对象：帧对象表示 python 的执行栈帧。帧对象包含 python 解释器在运行时所需要知道的所有信息
- 跟踪记录对象：当你的代码出错时, Python 就会引发一个异常。如果异常未被捕获和处理, 解释器就会退出脚本运行,显示诊断信息
- 切片对象：当使用 Python 扩展的切片语法时,就会创建切片对象。扩展的切片语法允许对不同的索引切片操作,包括步进切片, 多维切片,及省略切片。
- 省略对象：省略对象用于扩展切片语法中,起记号作用
- XRange 对象：调用内建函数 xrange() 会生成一个 Xrange 对象,xrange()是内建函数 range()的兄弟版本, 用于需要节省内存使用或 range()无法完成的超大数据集场合

#### 对象身份比较
每个对象都天生具有一个计数器,记录它自己的引用次数

整数对象和 字符串对象是不可变对象,所以Python会很高效的缓存它们。这会造成我们认为Python应该
创建新对象时,它却没有创建新对象的假象。看下面的例子:

    >>> a = 1
    >>> id(a)
    8402824
    >>> b = 1
    >>> id(b)
    8402824
    >>>
    >>> c = 1.0
    >>> id(c)
    8651220
    >>> d = 1.0
    >>> id(d)
    8651204

在上面的例子中,a 和 b 指向了相同的整数对象,但是 c 和 d 并没有指向相同的浮点数 对象。如果我们是纯粹主义者,我们会希望 a 与 b 能和 c 与 d 一样,因为我们本意就是为 了创建两个整数对象,而不是像 b = a 这样的结果。


### 标准类型

|函数|功能
|:--|:--
|cmp(obj1, obj2) |  比较 obj1 和 obj2，根据比较结果返回整数 i: <br> i \< 0 if obj1 \< obj2 <br> i > 0 if obj1 \> obj2 <br> i == 0 if obj1 == obj2
|repr(obj) 或 \`obj\`|返回一个对象的字符串表示
|str(obj)| 返回对象适合可读性好的字符串表示
|type(obj)|得到一个对象的类型，并返回相应的 type 对象

#### str()和 repr() (及 \`\` 运算符)
repr 和 str 都是将 python 对象以字符串表示，但是两者有一定的区别，repr() 输出对 Python 比较友好, 而 str()的输出对人比较友好。

repr 在处理浮点数的时候保留的小数位更多

**为什么有了 repr 还要 \`\`**：在Python学习过程中,你偶尔会遇到某个运算符和某个函数是做同样一件事情。之所以如 此是因为某些场合函数会比运算符更适合使用。事实上，现在 python 社区已经不鼓励继续使用\`\`

>
判断对象类型，可以通过利用 == 操作符比较 type(obj) 和要比较类型之间是否相等，另外也可以使用 `instance` 来进行比较


### 类型工厂函数
Python 2.2 统一了类型和类, 所有的内建类型现在也都是类, 在这基础之上, 原来的 所谓内建转换函数象 int(), type(), list() 等等, 现在都成了工厂函数。 也就是说虽然他 们看上去有点象函数, 实质上他们是类。当你调用它们时, 实际上是生成了该类型的一个实 例, 就象工厂生产货物一样。

#### 存储模型
Python 的类型, 就象绝大多数其它语言一样,能容纳一个或多个值。一个能保存单个字面对象的类型 我们称它为原子或标量存储,那些可容纳多个对象的类型,我们称之为容器存储。

|分类|python 类型
|:--|:--
|标量/原子类型|数值（所有的数值类型，字符串（全部是文字）
|容器类型|列表、元组、字典

#### 更新模型

|分类|python 类型
|:--|:--
|可变类型|列表、字典
|不可变类型|数字、字符串、元组

对不可变类型的变量改变值，实际上是新建了对象

#### 访问模型
在访问模型中共有三种访问方式：直接存取，顺序和映射

对非容器类型可以直接访问，所有数值类型都归到这一类

序列类型是值容器内的元素按从 0 开始的索引顺序访问。一次可以访问一个元素或多个元素，也就是所谓的切片（slice）。字符串，列表和元组都归到这一类。python 不支持字符串类型，但是它有能力按照顺序访问子字符串，所以它也归到序列类型

映射类型的元素 无序存放, 通过一个唯一的 key 来访问, 这就是映射类型, 它容纳的是哈希键-值对的集合。

### 不支持的类型
Python 目前还不支持的数据类型有 char 和 byte、指针

事实上在 python 中，一切都是指针。


