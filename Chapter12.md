#模块
Python 允许 "调入" 一个模块, 允许使用其他模块的属性来利用之前的工作成果, 实现代码重用. 这个把其他模块中属性附加到你的模块中的操作叫做导入(import) 。那些自我包含并且有组织的代 码片断就是模块( module  )。

### 搜索路径和路径搜索
可以通过 sys.path 访问搜索路径

sys.modules 可以找到当前导入了哪些模块和它们来自什么地方。 和 sys.path 不同, sys.modules 是一个字典, 使用模块名作为键( key ) , 对应物理地址作为值( value  )。

### 名称空间
名称空间是名称(标识符)到对象的映射

python 在执行期间有两个或三个活动的名称空间，这三个名称空间分别是局部名称空间，全局名称空间和内建名称空间。但局部名称空间在执行期间是不断变化的, 所以我 们说"两个或三个"。从名称空间中访问这些名字依赖于它们的加载顺序, 或是系统加载这些名称空 间的顺序。

Python 解释器首先加载内建名称空间。 它由 __builtins__ 模块中的名字构成。 随后加载执 行模块的全局名称空间, 它会在模块开始执行后变为活动名称空间。 这样我们就有了两个活动的名称空间。如果在执行期间调用了一个函数, 那么将创建出第三个名称空间, 即局部名称空间。 我们可以 通过 globals() 和 locals() 内建函数判断出某一名字属于哪个名称空间。我们将在本章后面详细 介绍这两个函数。


核心笔记: __builtins__ 和 __builtin__

\_\_builtins\_\_ 模块和 \_\_builtin\_\_ 模块不能混淆。 虽然它们的名字相似——尤其对于新手来 说。 \_\_builtins\_\_ 模块包含内建名称空间中内建名字的集合。 其中大多数(如果不是全部的话)来 自 \_\_builtin\_\_ 模块, 该模块包含内建函数, 异常以及其他属性。 在标准 Python 执行环境下, \_\_builtin\_\_ 包含 \_\_builtin\_\_ 的所有名字。 Python 曾经有一个限制执行模式, 允许你修改 \_\_builtins\_\_ , 只保留来自 \_\_builtin\_\_ 的一部分, 创建一个沙盒(sandbox)环境。但是, 因为 它有一定的安全缺陷, 而且修复它很困难, Python 已经不再支持限制执行模式。(如版本 2.3 )

### 名称空间与变量作用域比较
名称空间是纯粹意义上的名字和对象间的映射关系，而作用域还指出了从用户代码的哪些物理位置可以访问到这些名字。

注意每个名称空间是一个自我包含的单元。但从作用域的观点看，事情是不同的。所有局部名称空间的名称都在局部作用范围内。局部作用范围以外的所有名称都在全局作用范围内。


## 模块导入的特性
### 载入时执行模块

加载模块会导致这个模块被"执行"。 也就是被导入模块的顶层代码将直接被执行。 这通常包 括设定全局变量以及类和函数的声明。 如果有检查 \_\_name\_\_ 的操作, 那么它也会被执行。

### 导入（import）和加载（load）

一个模块只被加载一次, 无论它被导入多少次。 这可以阻止多重导入时代码被多次执行

只从模块导入名字的另一个副作用是那些名字会成为局部名称空间的一部分。 这可能导致覆盖一个已经存在的具有相同名字的对象。 而且对这些变量的改变只影响它的局部拷贝而不是所导入模 块的原始名称空间。 也就是说, 绑定只是局部的而不是整个名称空间。


### 关于 \_\_feature\_\_
为了让 Python 程序员为新事物做好准备, Python 实现了 __future__ 指令。

使用 from-import 语句"导入"新特性, 用户可以尝试一下新特性或特性变化, 以便在特性固 定下来的时候修改程序。 它的语法是:

    from __future__ import new_feature

## 模块内建函数
### \_\_import\_\_()
Python 1.5 加入了 \_\_import\_\_() 函数, 它作为实际上导入模块的函数, 这意味着 import 语句调用 \_\_import\_\_() 函数完成它的工作。􏰀供这个函数是为了让有特殊需要的用户覆盖它, 实现 自定义的导入算法。

    __import__(module_name[, globals[, locals[, fromlist]]])


### globals() 和 locals()
globals() 和 locals() 内建函数分别返回调用者全局和局部名称空间的字典，在一个函数内 部, 局部名称空间代表在**函数执行时候**定义的所有名字, locals() 函数返回的就是包含这些名字 的字典。 globals() 会返回函数可访问的全局名字。

### 导入循环
实际上,在使用 Python 时, 你会发现是能够导入循环的。 如果你开发了大型的 Python 工程, 那么你很可能会陷入这样的境地。

解决这个问题几乎总是移除其中一个导入语句. 或者将一个模块的 import 语句移到函数内部
